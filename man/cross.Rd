% Generated by roxygen2 (4.1.0.9001): do not edit by hand
% Please edit documentation in R/cross.R
\name{cross}
\alias{cross}
\alias{cross3}
\alias{cross_n}
\title{Produce all combinations of list elements}
\usage{
cross(.x, .y, .wide = TRUE, .filter = NULL)

cross3(.x, .y, .z, .wide = TRUE, .filter = NULL)

cross_n(.l, .wide = TRUE, .filter = NULL)
}
\arguments{
\item{.x,.y,.z}{Lists or atomic vectors.}

\item{.wide}{If \code{TRUE}, returns a list of unique combinations.
If \code{FALSE}, returns a list of the same size as the number of
arguments (2 for \code{cross()}, 3 for \code{cross3()},
\code{length(.l)} for \code{cross_n()}).}

\item{.filter}{A predicate function}

\item{.l}{A list of lists or atomic vectors.}
}
\value{
A list or a data frame.
}
\description{
\code{cross()} returns the product set of the elements of \code{.x}
and \code{.y}. It is similar to \code{expand.grid()} but it returns
a list. By default, the cartesian product is returned in wide
format. This makes it more amenable to mapping
operations. Switching \code{.wide} to \code{FALSE} turns the output
to the long format, the equivalent to \code{expand.grid()}'s
outputs.
}
\details{
\code{cross3()} takes three three arguments instead of two and
returns the cartesian product of the elements of the three
objects. \code{cross_n()} takes a list \code{.l} and returns the
cartesian product of all its elements. If \code{.l} is a data
frame, \code{cross_n()} returns a data frame.

When the number of combinations is large and the individual elements
are heavy memory-wise, it is often useful to filter unwanted
combinations on the fly. \code{.filter} must be a predicate
functio! that takes the same number of arguments as the number of
crossed objects (2 for \code{cross()}, 3 for \code{cross3()},
\code{length(.l)} for \code{cross_n()}) and returns \code{TRUE} or
\code{FALSE}. The combinations where the predicate function returns
\code{TRUE} will be removed from the result.
}
\examples{
# We build all combinations of names, greetings and separators from our
# list of data and pass each one to paste()
data <- list(
  id = c("John", "Jane"),
  greeting = c("Hello.", "Bonjour."),
  sep = c("! ", "... ")
)

data \%>\%
  cross_n() \%>\%
  map(splat(paste))

# For this purpose, the long format is less pratical and requires a loop
args <- cross_n(data, .wide = FALSE)

out <- vector("list", length(args[[1]]))
for (i in seq_along(out))
  out[[i]] <- map(args, i) \%>\% splat(paste)()
out
}
\seealso{
expand.grid
}

